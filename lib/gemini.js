/**
 * Google Gemini API Client
 *
 * 작성자: 최진호
 * 작성일: 2026-02-13
 *
 * Gemini 2.0 Flash 모델 지원
 */

import fetch from "node-fetch";
import { spawn } from "child_process";

const GEMINI_API_KEY = process.env.GEMINI_API_KEY || "";
const GEMINI_BASE_URL = "https://generativelanguage.googleapis.com/v1beta";
const DEFAULT_MODEL = "gemini-2.0-flash";

/**
 * Gemini API로 텍스트 생성
 * @param {string} prompt - 프롬프트
 * @param {Object} options - 옵션
 * @returns {Promise<string>} 생성된 텍스트
 */
export async function generateContent(prompt, options = {}) {
  if (!GEMINI_API_KEY) {
    throw new Error("GEMINI_API_KEY environment variable is not set");
  }

  const model = options.model || DEFAULT_MODEL;
  const temperature = options.temperature ?? 0.7;
  const maxTokens = options.maxTokens || 8000;

  const url = `${GEMINI_BASE_URL}/models/${model}:generateContent?key=${GEMINI_API_KEY}`;

  const requestBody = {
    contents: [
      {
        parts: [
          {
            text: prompt
          }
        ]
      }
    ],
    generationConfig: {
      temperature,
      maxOutputTokens: maxTokens,
      topP: 0.95,
      topK: 40
    },
    safetySettings: [
      {
        category: "HARM_CATEGORY_HARASSMENT",
        threshold: "BLOCK_NONE"
      },
      {
        category: "HARM_CATEGORY_HATE_SPEECH",
        threshold: "BLOCK_NONE"
      },
      {
        category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
        threshold: "BLOCK_NONE"
      },
      {
        category: "HARM_CATEGORY_DANGEROUS_CONTENT",
        threshold: "BLOCK_NONE"
      }
    ]
  };

  const response = await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(requestBody)
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Gemini API error: ${response.status} ${errorText}`);
  }

  const data = await response.json();

  if (!data.candidates || data.candidates.length === 0) {
    throw new Error("No content generated by Gemini");
  }

  const candidate = data.candidates[0];

  if (!candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {
    throw new Error("Invalid response structure from Gemini");
  }

  return candidate.content.parts[0].text;
}

/**
 * MediaWiki 마크업 생성
 * @param {string} topic - 주제
 * @param {Object} options - 옵션
 * @returns {Promise<string>} MediaWiki 마크업
 */
export async function generateWikiContent(topic, options = {}) {
  const category = options.category || "일반";
  const includeImages = options.includeImages ?? false;
  const tone = options.tone || "전문적";

  const prompt = `
당신은 MediaWiki 전문 작가입니다.

주제: ${topic}
카테고리: ${category}
톤: ${tone}

다음 형식으로 MediaWiki 마크업을 생성하세요:

== 개요 ==
주제에 대한 명확한 소개 (2-3 문장)

== 상세 내용 ==
=== 주요 개념 ===
핵심 개념 설명

=== 특징 ===
* 특징 1: 설명
* 특징 2: 설명
* 특징 3: 설명

=== 사용 예시 ===
실제 사용 예시 또는 활용 방법

${includeImages ? "=== 관련 이미지 ===\n[[File:example.png|thumb|설명]]\n" : ""}

== 참고 자료 ==
* [[관련 문서 1]]
* [[관련 문서 2]]
* [https://example.com 외부 링크]

== 같이 보기 ==
* [[관련 주제 1]]
* [[관련 주제 2]]

[[Category:${category}]]

규칙:
- 반드시 MediaWiki 마크업 사용
- 한국어로 작성
- 명확하고 간결하게
- 최소 3개 섹션 이상
- 카테고리 태그 필수 포함
- 실제 링크는 대괄호 2개 사용
`;

  return await generateContent(prompt, {
    temperature: 0.8,
    maxTokens: 4000,
    ...options
  });
}

/**
 * 문서 개선 제안
 * @param {string} currentContent - 현재 콘텐츠
 * @param {Object} options - 옵션
 * @returns {Promise<string>} 개선된 콘텐츠
 */
export async function improveWikiContent(currentContent, options = {}) {
  const focus = options.focus || "전반적 개선";

  const prompt = `
당신은 MediaWiki 편집 전문가입니다.

현재 문서 내용:
${currentContent}

개선 초점: ${focus}

다음 사항을 고려하여 문서를 개선하세요:
1. 구조 명확화 (섹션 구분, 제목 계층)
2. 내용 풍부화 (부족한 정보 추가)
3. 링크 추가 (관련 문서 연결)
4. 카테고리 정리
5. 문법 및 표현 개선
6. MediaWiki 마크업 표준 준수

개선된 전체 문서를 MediaWiki 마크업으로 출력하세요.
`;

  return await generateContent(prompt, {
    temperature: 0.7,
    maxTokens: 6000,
    ...options
  });
}

/**
 * 사용 가능한 Gemini 모델 목록
 */
export const GEMINI_MODELS = {
  PRO:     "gemini-2.0-flash",
  FLASH:   "gemini-2.0-flash",
  PRO_EXP: "gemini-2.0-flash-exp"
};

/**
 * Gemini CLI 설치 여부 확인
 *
 * @returns {Promise<boolean>}
 */
let _geminiCLICached = null;

export async function isGeminiCLIAvailable() {
  if (_geminiCLICached !== null) return _geminiCLICached;
  try {
    const { execSync } = await import("child_process");
    execSync("which gemini", { stdio: "ignore", timeout: 5000 });
    _geminiCLICached = true;
  } catch {
    _geminiCLICached = false;
  }
  return _geminiCLICached;
}

/**
 * Gemini CLI로 짧은 JSON 응답 생성
 *
 * 모순 탐지, 품질 평가, 자동 요약 등 "프롬프트 → JSON 응답" 패턴에 사용.
 * runGeminiCLI를 호출한 뒤 JSON 파싱까지 처리한다.
 *
 * @param {string} prompt   - JSON 응답을 요구하는 프롬프트
 * @param {Object} options  - { timeoutMs, model }
 * @returns {Promise<Object>} 파싱된 JSON 객체
 */
export async function geminiCLIJson(prompt, options = {}) {
  const timeoutMs = options.timeoutMs || 30_000;
  const raw       = await runGeminiCLI("", prompt, {
    timeoutMs,
    model: options.model
  });
  const cleaned = raw.replace(/```json\s*|\s*```/g, "").trim();
  return JSON.parse(cleaned);
}

/**
 * Gemini CLI로 텍스트 생성 (stdin 컨텍스트 + -p 프롬프트)
 *
 * @param {string} stdinContent - stdin으로 전달할 컨텍스트
 * @param {string} prompt       - -p 옵션으로 전달할 지시 프롬프트
 * @param {Object} options      - 옵션 (timeoutMs)
 * @returns {Promise<string>} Gemini CLI 출력 텍스트
 */
export async function runGeminiCLI(stdinContent, prompt, options = {}) {
  const timeoutMs = options.timeoutMs || 360_000;

  return new Promise((resolve, reject) => {
    // MCP 도구(brave 웹서치 등) 자동 승인을 위해 yolo 모드 사용
    const args  = ["-p", prompt, "--output-format", "text", "-y"];
    const model = options.model;
    if (model) args.push("--model", model);

    const proc = spawn("gemini", args, {
      env:   { ...process.env },
      stdio: ["pipe", "pipe", "pipe"]
    });

    let stdout  = "";
    let stderr  = "";
    let settled = false;

    const timer = setTimeout(() => {
      if (!settled) {
        settled = true;
        proc.kill("SIGTERM");
        reject(new Error(`Gemini CLI timed out after ${timeoutMs}ms`));
      }
    }, timeoutMs);

    proc.stdout.on("data", (data) => { stdout += data.toString(); });
    proc.stderr.on("data", (data) => { stderr += data.toString(); });

    proc.on("close", (code) => {
      clearTimeout(timer);
      if (settled) return;
      settled = true;
      if (code !== 0) {
        reject(new Error(`Gemini CLI exited with code ${code}: ${stderr.trim()}`));
      } else {
        resolve(stdout.trim());
      }
    });

    proc.on("error", (err) => {
      clearTimeout(timer);
      if (!settled) {
        settled = true;
        reject(new Error(`Gemini CLI spawn error: ${err.message}`));
      }
    });

    if (stdinContent) {
      proc.stdin.write(stdinContent, "utf8");
    }
    proc.stdin.end();
  });
}

/**
 * Brave Search API 직접 호출 (컨테이너 내부 호환 — web-search-module 미사용)
 *
 * @param {string} query    - 검색 쿼리
 * @param {Object} options  - { count, search_lang, country }
 * @returns {Promise<{success:boolean, results:Array}|null>}
 */
async function braveSearch(query, options = {}) {
  const apiKey = process.env.BRAVE_API_KEY;
  if (!apiKey) {
    console.log("[Gemini/BraveSearch] BRAVE_API_KEY not set, skipping search");
    return null;
  }

  const params = new URLSearchParams({
    q:           query,
    count:       String(options.count || 5),
    search_lang: options.search_lang || "en",
    country:     "KR"
  });

  try {
    console.log(`[Gemini/BraveSearch] Searching: "${query}"`);
    const response = await fetch(
      `https://api.search.brave.com/res/v1/web/search?${params}`,
      {
        headers: {
          "X-Subscription-Token": apiKey,
          "Accept":               "application/json"
        }
      }
    );

    if (!response.ok) {
      console.log(`[Gemini/BraveSearch] API error: ${response.status}`);
      return null;
    }

    const data    = await response.json();
    const results = (data.web?.results || []).map(r => ({
      title:   r.title   || "",
      url:     r.url     || "",
      snippet: r.description || ""
    }));

    console.log(`[Gemini/BraveSearch] Found ${results.length} results`);
    return { success: true, count: results.length, results };
  } catch (err) {
    console.error(`[Gemini/BraveSearch] Failed: ${err.message}`);
    return null;
  }
}

/**
 * Brave Search로 자료 조사 후 Gemini CLI로 MediaWiki 마크업 생성
 *
 * 조사 순서:
 *   1) 나무위키 페이지  → 형식·구성 참고 우선
 *   2) 한국어 일반 검색 → 개요·특징·활용
 *   3) 영어 일반 검색   → 국제적 맥락
 *   4) 학술 논문 검색   → 원전·학술 인용
 * Gemini CLI가 추가 조사가 필요하면 brave MCP·nerdvana MCP(한국고전DB 포함)를 직접 사용.
 *
 * @param {string} topic    - 위키 주제
 * @param {Object} options  - 옵션 (category, tone, includeImages, model, timeoutMs)
 * @returns {Promise<string>} MediaWiki 마크업
 */
export async function generateWikiContentWithCLI(topic, options = {}) {
  const category      = options.category     || "일반";
  const tone          = options.tone         || "전문적";
  const includeImages = options.includeImages ?? false;

  // 1. Brave Search — 4개 쿼리 병렬 수집 (직접 API 호출)
  const [namuResult, koResult, enResult, scholarResult] = await Promise.allSettled([
    braveSearch(`나무위키 ${topic}`,                     { count: 3, search_lang: "ko" }),
    braveSearch(topic,                                   { count: 5, search_lang: "ko" }),
    braveSearch(`${topic} overview`,                     { count: 5, search_lang: "en" }),
    braveSearch(`${topic} 논문 연구 학술 OR paper research`, { count: 4, search_lang: "ko" })
  ]);

  // 2. 검색 결과를 stdin 컨텍스트로 조합
  const lines = [`# 주제: ${topic}`, ""];

  const addResults = (label, res) => {
    if (res.status !== "fulfilled" || !res.value?.results?.length) return;
    lines.push(`## ${label}`);
    for (const r of res.value.results) {
      lines.push(`- **${r.title}**`);
      if (r.snippet) lines.push(`  ${r.snippet}`);
      if (r.url)     lines.push(`  출처: ${r.url}`);
    }
    lines.push("");
  };

  addResults("나무위키 검색 결과 (형식·내용 우선 참고)", namuResult);
  addResults("한국어 검색 결과",                         koResult);
  addResults("영어 검색 결과",                           enResult);
  addResults("학술·논문 검색 결과",                      scholarResult);

  const stdinContext = lines.join("\n");

  // 3. Gemini CLI 프롬프트 구성
  const prompt = `당신은 MediaWiki 전문 편집자입니다.
위 사전 조사 결과를 바탕으로 "${topic}"에 대한 위키 문서를 작성하세요.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[필수] 자료 조사 절차 (작성 전 반드시 수행)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. 나무위키 참고 (최우선)
   - 위 "나무위키 검색 결과"에 나무위키 URL이 있으면 brave MCP의 brave_web_search로
     해당 페이지를 직접 방문하여 문서 구성·섹션 순서·목차·서술 방식을 파악한다.
   - 나무위키의 구성을 참고하되, 내용은 독립적으로 재서술한다(저작권 침해 금지).

2. 학술 논문·원전 인용 (가능하면 필수)
   - "학술·논문 검색 결과"에서 DOI·arXiv·학술지 URL을 확인한다.
   - 인용 가능한 논문·원전·보고서가 있으면 반드시 == 참고 자료 == 섹션에 포함한다.
   - 인용 형식: * 저자, "제목", 학술지/출처, 연도. [https://doi.org/... DOI]

3. 한국 고전 자료 검색 (해당 주제 시)
   - 주제가 한국 역사·문학·문화·철학·인물·고전과 관련 있다면 nerdvana MCP의
     korean_classics_search 도구로 한국고전통합DB를 검색하여 원전 기록을 확인한다.
   - 고전 자료가 발견되면 == 원전 기록 == 섹션을 추가하고 인용한다.

4. 추가 조사
   - 위 자료만으로 부족하면 brave MCP(brave_web_search)로 추가 검색을 수행한다.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[필수] MediaWiki 마크업 규칙 (절대 준수)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
- 출력은 반드시 MediaWiki 마크업만 사용한다.
- HTML 태그(<div>, <span>, <br> 등) 사용 금지.
- 마크다운(#, **, __, 코드블록 등) 사용 금지.
- 섹션 제목: == 제목 ==, === 소제목 ===, ==== 소소제목 ====
- 목록: * 항목 (비순서), # 항목 (순서)
- 링크: [[내부 링크]], [https://url 설명] (외부 링크)
- 굵게: '''굵게''', 기울임: ''기울임''
- 표: {| class="wikitable" ... |}
- 카테고리: [[Category:${category}]] (문서 맨 끝)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
문서 설정
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
- 카테고리: ${category}
- 톤: ${tone}
- 언어: 한국어
- 최소 섹션: 4개 이상
${includeImages ? "- 이미지: [[File:파일명.확장자|thumb|설명]] 문법으로 이미지 섹션 포함" : ""}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
권장 문서 구조 (나무위키 참고 후 조정 가능)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
== 개요 ==
== 역사 / 배경 ==   (해당 시)
== 상세 내용 ==
=== 주요 개념 ===
=== 특징 ===
=== 활용 사례 ===
== 원전 기록 ==     (고전·역사 주제 시)
== 참고 자료 ==     (논문·출처 인용 필수)
== 같이 보기 ==
[[Category:${category}]]

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
최종 출력: MediaWiki 마크업만 출력하고, 설명·주석·코드블록 없이 문서 내용만 출력하세요.`;

  return await runGeminiCLI(stdinContext, prompt, {
    model:     options.model,
    timeoutMs: options.timeoutMs || 540_000   // 추가 조사 시간 고려하여 9분
  });
}

/**
 * 기존 위키 문서를 Brave Search + Gemini CLI로 보강
 *
 * 기존 마크업을 읽어 부족한 섹션을 채우고, 최신 자료를 추가하며,
 * 학술 인용·한국고전DB 조회를 통해 내용을 강화한다.
 *
 * @param {string} topic          - 위키 주제 (검색 쿼리용)
 * @param {string} existingContent - 기존 위키 마크업
 * @param {Object} options         - 옵션 (category, focus, model, timeoutMs)
 * @returns {Promise<string>} 보강된 MediaWiki 마크업
 */
export async function enhanceWikiContentWithCLI(topic, existingContent, options = {}) {
  const category = options.category || "일반";
  const focus    = options.focus    || "전반적 보강";

  // 1. 최신 자료 추가 수집 (기존 문서에 없을 수 있는 최신 정보 위주)
  const [namuResult, scholarResult, enResult] = await Promise.allSettled([
    braveSearch(`나무위키 ${topic}`,                          { count: 3, search_lang: "ko" }),
    braveSearch(`${topic} 논문 연구 최신 OR paper research`,  { count: 4, search_lang: "ko" }),
    braveSearch(`${topic} latest research`,                   { count: 3, search_lang: "en" })
  ]);

  // 2. stdin 컨텍스트 구성 (기존 문서 + 추가 자료)
  const lines = [
    `# 주제: ${topic}`,
    "",
    "## 기존 위키 문서 (보강 대상)",
    existingContent,
    ""
  ];

  const addResults = (label, res) => {
    if (res.status !== "fulfilled" || !res.value?.results?.length) return;
    lines.push(`## ${label}`);
    for (const r of res.value.results) {
      lines.push(`- **${r.title}**`);
      if (r.snippet) lines.push(`  ${r.snippet}`);
      if (r.url)     lines.push(`  출처: ${r.url}`);
    }
    lines.push("");
  };

  addResults("나무위키 참고 (형식·내용 참고)",  namuResult);
  addResults("학술·논문 자료",                   scholarResult);
  addResults("영어 자료",                         enResult);

  const stdinContext = lines.join("\n");

  // 3. 보강 프롬프트
  const prompt = `당신은 MediaWiki 전문 편집자입니다.
"기존 위키 문서"를 아래 추가 자료를 참고하여 보강하세요.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[필수] 보강 절차
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
보강 초점: ${focus}

1. 기존 문서 분석
   - 부족하거나 비어 있는 섹션을 파악한다.
   - 출처가 없는 주장을 확인한다.
   - 구조가 나무위키보다 단순하면 목차를 보강한다.

2. 나무위키 참고
   - 나무위키 URL이 있으면 brave MCP의 brave_web_search로 직접 방문하여
     기존 문서에 없는 섹션·내용을 파악한다.

3. 학술 인용 추가
   - 학술·논문 자료에서 DOI·학술지 URL이 있으면 == 참고 자료 == 에 추가한다.

4. 한국 고전 자료 검색 (해당 주제 시)
   - 주제가 한국 역사·문화·고전과 관련 있으면 nerdvana MCP의
     korean_classics_search 도구로 원전 기록을 확인하고 == 원전 기록 == 섹션을 추가한다.

5. 추가 조사
   - 위 자료만으로 부족하면 brave MCP로 추가 검색한다.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[필수] MediaWiki 마크업 규칙 (절대 준수)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
- 출력은 반드시 MediaWiki 마크업만 사용한다.
- HTML 태그(<div>, <span>, <br> 등) 사용 금지.
- 마크다운(#, **, __, 코드블록 등) 사용 금지.
- 섹션 제목: == 제목 ==, === 소제목 ===
- 목록: * 항목 (비순서), # 항목 (순서)
- 링크: [[내부 링크]], [https://url 설명] (외부 링크)
- 굵게: '''굵게''', 기울임: ''기울임''
- 카테고리: [[Category:${category}]] (문서 맨 끝)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
최종 출력: 보강된 전체 문서를 MediaWiki 마크업으로만 출력하세요.
설명·주석·diff 없이 완성된 문서 전체를 출력하세요.`;

  return await runGeminiCLI(stdinContext, prompt, {
    model:     options.model,
    timeoutMs: options.timeoutMs || 540_000
  });
}

/**
 * Gemini API 상태 확인
 */
export async function checkGeminiStatus() {
  if (!GEMINI_API_KEY) {
    return {
      available: false,
      error: "GEMINI_API_KEY not configured"
    };
  }

  try {
    await generateContent("Test", { maxTokens: 10 });
    return {
      available: true,
      model: DEFAULT_MODEL
    };
  } catch (error) {
    return {
      available: false,
      error: error.message
    };
  }
}
